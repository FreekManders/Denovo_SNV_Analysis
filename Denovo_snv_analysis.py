import argparse
import os
import sys
import re
import datetime
from timeit import default_timer as timer


####____________________Start timer______________________####
start = timer()
time = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M")
print "Start running pipeline at: {0}".format(time)

####____________________Function to parse ini files_______####
def ini_parser(ini_fname):
	r"""Parses a ini file with a key\tvalue format and returns a dictionary"""
	if not os.path.isfile(ini_fname): raise IOError("The ini file could not be read. This has caused an error.")
	ini_dict = {}
	with open(ini_fname) as ini:
		for line in ini:
			line = line.strip()
			if line.startswith("#") or line == "":
				continue
			if "\t" in line:
				key, value = line.split("\t")
			else:
				key = line
				value = ""
			ini_dict[key] = value
	return ini_dict
	

####______________________Get location of the pipeline____####
pathname = os.path.dirname(sys.argv[0])        
pipeline_path = os.path.abspath(pathname)

####______________________Parse arguments_________________####
parser = argparse.ArgumentParser(description = "This script runs the entire autosomal denovo snv analyis pipeline. Output from the UMCU IAP pipeline is used as its input.")
parser.add_argument("-i", "--ini", default = "/hpc/cog_bioinf/cuppen/project_data/Freek_SNV/pipeline/Denovo_snv_analysis.ini", help = "The input ini file")
args = parser.parse_args()

####_______________________Parse the ini file_______________####
ini_dict = ini_parser(args.ini)

#Main configurations
output_path = ini_dict["OUTPUT_PATH"]
filelist = ini_dict["FILELIST"]
log = ini_dict["OVERVIEW_LOG"].lower()
email = ini_dict["EMAIL"]
overwrite = ini_dict["OVERWRITE"].lower()

#Modules. These can be loaded via the module system.
python = ini_dict["PYTHON"]
R = ini_dict["R"]
bedtools = ini_dict["BEDTOOLS"]
vcftools = ini_dict["VCFTOOLS"]
tabix = ini_dict["TABIX"]
bcftools = ini_dict["BCFTOOLS"]

#Other software. These are often .jar fileS.
gatk = ini_dict["GATK"]
snpsift = ini_dict["SNPSIFT"]
denovogear = ini_dict["DENOVOGEAR"]

#Data. This is data, that wasn't generated by the IAP or this pipeline.
genome = ini_dict["GENOME"]

####__________________General preparations____________________####
#Create the directories needed in the output_path.
with open(os.path.join(pipeline_path, "dirlist.txt")) as dirlist:
	for line in dirlist:
		dir_path = line.strip()
		dir_path = os.path.join(output_path, dir_path)
		if not os.path.isdir(dir_path):
			os.mkdir(dir_path)

#initialize a log file of all the modules that have been used.
if log == "true":
	modulesusedlog_fname = "{0}/Logs/modules_used_{1}.txt".format(output_path, time)
	with open(modulesusedlog_fname, "w") as f:
		pass

#Standard arguments for the scripts.
std_arguments = "--FILELIST {0} --OUTPUT_PATH {1} --OVERWRITE {2}".format(filelist, output_path, overwrite)

####_________________________Function to create bash files.__________________________________####
def create_bash(mode, scriptname, modules, language, arguments = std_arguments, pipeline_path = pipeline_path, output_path = output_path, time = time, log = log, email = email, hold_jid = "", threads = 1, nr = ""):
	"""Creates and runs a bash submission script.
	
	As its input you need to provide the mode to run as well as the name of the script itself, its arguments and the language in which the script was written. The function also uses several global variables as default values."""
	
	#Look up some of the ini settings
	if ini_dict[mode].lower() != "true":
		return
		
	h_rt = ini_dict["{0}_TIME".format(mode)]
	h_vmem = ini_dict["{0}_MEM".format(mode)]
	beas = ini_dict["{0}_BEAS".format(mode)]
	log_script = ini_dict["{0}_LOG".format(mode)]
	
	#start writing the bash
	scriptnamenoextension = os.path.splitext(scriptname)[0]
	bash_fname = "{0}/Jobs/{1}_{2}{3}.sh".format(output_path, scriptnamenoextension, time, nr)
	with open(bash_fname, "w") as bash_file:
		
		#Create the general settings of the bash script
		bash_file.write("#!/bin/bash\n#$ -S /bin/bash\n#$ -l h_rt={0}\n#$ -l h_vmem={1}\n#$ -cwd\n#$ -N {2}\n".format(h_rt, h_vmem, scriptnamenoextension))
		
		if log_script.lower() == "true":
			bash_file.write("#$ -o {0}/Logs/{1}_{2}_output\n#$ -e {0}/Logs/{1}_{2}_errors\n".format(output_path, scriptnamenoextension, time))
		else:
			bash_file.write("#$ -o /dev/null\n#$ -e /dev/null\n")
		
		if hold_jid is not "":
			bash_file.write("#$ -hold_jid {0}\n".format(hold_jid))
		
		if threads != 1:
			bash_file.write("#$ -pe threaded {0}\n".format(threads))
		
		if email is not "":
			bash_file.write("#$ -M {0}\n".format(email))
		
		if beas is not "":
			bash_file.write("#$ -m {0}\n".format(beas))
		
		#Log the time the scripts starts running
		if log == "true":
			bash_file.write("""echo "running {0} on $(date)" >> {1}\n""".format(scriptnamenoextension, modulesusedlog_fname))
	
		#module loading
		for module in modules:
			bash_file.write("module load {0}\n".format(module))

		#Create the call to the script that needs to be run
		script_abspath = os.path.join(pipeline_path, scriptname)
		bash_file.write("{0} {1} {2}\n".format(language, script_abspath, arguments))
	
		#module unloading
		for module in modules:
			bash_file.write("module unload {0}\n".format(module))
	
		#Log the time the script finished running.
		if log == "true":
			bash_file.write("""echo "Finished running {0} on $(date)" >> {1}\n""".format(scriptnamenoextension, modulesusedlog_fname))
		
	#Run the bash file
	os.system("qsub {0}".format(bash_fname))


####__________Run the different parts of the pipeline._______####	

#WGS_QC
create_bash(mode = "WGS_QC", scriptname = "WGS_QC_plots.R", modules = [R], language = "Rscript")

#CallableLoci
create_bash(mode = "CallableLoci", scriptname = "GetCallableLoci.py", modules = [python, bedtools], language = "python")

#Callableregions_and_runPbt
arguments = "{0} --GATK {1} --GENOME {2} --THREADS {3}".format(std_arguments, gatk, genome, ini_dict["Callableregions_and_runPbt_THREADS"])
create_bash(mode = "Callableregions_and_runPbt", scriptname = "Callableregions_and_runPbt.py", threads = ini_dict["Callableregions_and_runPbt_THREADS"], hold_jid = "GetCallableLoci", modules = [python, vcftools], language = "python", arguments = arguments)

#Remove_missingGTs_MendelViol
create_bash(mode = "Remove_missingGTs_MendelViol", scriptname = "Remove_missingGTs_MendelViol.py", hold_jid = "Callableregions_and_runPbt", modules = [python], language = "python")

#Intersect_mendelviol_phasedvcf
create_bash(mode = "Intersect_mendelviol_phasedvcf", scriptname = "Intersect_mendelviol_phasedvcf.py", hold_jid = "Remove_missingGTs_MendelViol", modules = [python, vcftools], language = "python")

#Callableregions_and_runPbt_3kids
families_3kids = ini_dict["Callableregions_and_runPbt_3kids_FAMILY"]
families_3kids = families_3kids.split(",")
for i in range(len(families_3kids)):
	family = families_3kids[i]
	nr = "_nr{0}".format(i+1)
	arguments = "{0} --GATK {1} --GENOME {2} --FAMILY {3}".format(std_arguments, gatk, genome, family)
	create_bash(mode = "Callableregions_and_runPbt_3kids", scriptname = "Callableregions_and_runPbt_3kids.py", hold_jid = "GetCallableLoci", modules = [python, vcftools], language = "python", arguments = arguments, nr = nr)

#FilterDenovo
arguments = "{0} --SNPSIFT {1}".format(std_arguments, snpsift)
create_bash(mode = "FilterDenovo", scriptname = "FilterDenovo.py", hold_jid = "Intersect_mendelviol_phasedvcf,Callableregions_and_runPbt_3kids", modules = [python, vcftools], language = "python", arguments = arguments)

#denovogear
arguments = "{0} --SNPSIFT {1} --DENOVOGEAR {2}".format(std_arguments, snpsift, denovogear)
create_bash(mode = "denovogear", scriptname = "denovogear.py", hold_jid = "FilterDenovo", modules = [python, bcftools, tabix], language = "python", arguments = arguments)

####____________________End timer_____________________####
timeend = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M")
print "Finished submitting pipeline at: {0}".format(timeend)
end = timer()
execution_time = int(end - start)
execution_time = datetime.timedelta(seconds = execution_time)
print "Elapsed time: {0}".format(execution_time)

		
